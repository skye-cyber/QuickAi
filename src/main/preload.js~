const { contextBridge, ipcRenderer, shell } = require('electron');
const crypto = require('crypto');
const { Buffer } = require('buffer');
const fs = require('fs');
const path = require('path');
const os = require('os')
//const readFileSync = require('read-file-relative');


contextBridge.exposeInMainWorld('electron', {
    getEnv: () => ipcRenderer.invoke('get-env'),
    getBufferFromIV: (iv) => ipcRenderer.invoke('get-buffer-from-iv', iv),
    scryptSync: (password, salt, keylen) => crypto.scryptSync(password, salt, keylen),
    Buffer,
    getDownloadsPath: () => {
        const homedir = os.homedir();
        const downloadsPath = path.join(homedir, 'Downloads');
        return downloadsPath;
    },
    home_dir: () => {
        return os.homedir()
    },

    mkdir: async (dir) => {
        try{
            if (!fs.existsSync(dir)){
                fs.mkdirSync(dir)
            }
            return true
        } catch (err){
            console.log(err)
            return false
        }
    },

    write: async (path, data) =>{
        try{
            fs.writeFileSync(path, data, (err) => {
                if (err) throw err;
                console.log('The file has been saved!');
            });
            return true
        } catch (err){
            console.log(err)
            return false
        }
    },

    read: async (path) =>{
        try{
            if (fs.statSync){
                return JSON.parse(fs.readFile(path, 'utf-8'));
            }
        } catch (err){
            console.log(err)
            return false
        }
    },

    readDir: async (dir) =>{
        try{
            files = fs.readdirSync(dir)
            return files
        } catch (err){
            console.log(err)
            return false
        }
    },

    saveAndOpenImage: (downloadsPath, dataUrl) => {
        fetch(dataUrl)
        .then(res => res.blob())
        .then(blob => {
            const reader = new FileReader();
            reader.onloadend = () => {
                const buffer = Buffer.from(reader.result);
                const outputPath = path.join(downloadsPath, 'output.jpg');

                fs.writeFile(outputPath, buffer, (err) => {
                    if (err) {
                        console.error('Error saving image:', err);
                    } else {
                        shell.openPath(outputPath);
                    }
                });
            };
            reader.readAsArrayBuffer(blob);
        })
        .catch((error) => {
            console.error('Error creating blob:', error);
        });
    },
});
