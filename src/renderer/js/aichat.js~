import { HfInference } from "@huggingface/inference";
import { marked } from "marked";
import hljs from 'highlight.js';
import { get_key } from './Pcrypto.js';

let h_faceKey = null; // Define h_faceKey globally

window.electron.getEnv().then(env => {
    const encryptedOBJ = {
        iv: env.IV,
        encryptedData: env.API_OBJ
    };

    const SKEY = env.SKEY;
    const keyObject = get_key(encryptedOBJ, SKEY);

    keyObject.then(result => {
        h_faceKey = result;
        const client = new HfInference(h_faceKey);
        initChat(client);
    }).catch(error => {
        console.error("Error:", error);
    });
});

function initChat(client) {
    const chatArea = document.getElementById("chatArea");
    const userInput = document.getElementById("userInput");
    const sendBtn = document.getElementById("sendBtn");
    const modeSelect = document.getElementById('mode');

    // Custom instructions
    const customInstructions = `Your name is QuickAi...`; // full instructions omitted for brevity
    let conversationHistory = [{ role: "system", content: customInstructions }];

    // Initialize highlight.js
    hljs.configure({ ignoreUnescapedHTML: true });

    // Custom renderer for syntax highlighting
    const renderer = new marked.Renderer();
    renderer.code = function (code, language) {
        // Handle case where `code` is an object
        const validLanguage = code.lang || 'plaintext';
        console.log(`Language: ${validLanguage}`);
        if (typeof code === "object" && code.text !== undefined) {
            code = code.text; // Extract the actual code
        }

        if (typeof code !== "string" || code.trim() === "") {
            console.warn("Empty or invalid code provided:", code);
            code = "// No code provided"; // Default fallback for empty code
        }

        // Highlight the code
        let highlighted;
        try {
            highlighted = hljs.highlight(code, { language: validLanguage }).value;
        } catch (error) {
            console.error("Highlighting error:", error);
            highlighted = hljs.highlightAuto(code).value; // Fallback to auto-detection
        }

        // Generate unique ID for the copy button
        const copyButtonId = `copy-button-${Math.random().toString(36).substring(2, 9)}`;

        return `
        <div class="relative my-auto p-2 border border-gray-300 bg-white rounded-md">
        <button id="${copyButtonId}"
        class="copy-button absolute rounded-md px-2 py-2 right-2 top-2 bg-gradient-to-r from-sky-800 to-purple-600 hover:bg-blue-400 text-white border border-2 cursor-pointer opacity-80 hover:opacity-50 dark:bg-gray-800">
        Copy
        </button>
        <pre class="rounded-md dark:bg-gray-800">
        <code class="hljs ${validLanguage}">${highlighted}</code>
        </pre>
        </div>
        `;
    };

    // Configure marked.js
    marked.setOptions({
        renderer: renderer,
        highlight: function (code, lang) {
            // Handle case where `code` is an object
            const validLanguage = code.lang || 'plaintext';
            if (typeof code === "object" && code.text !== undefined) {
                code = code.text; // Extract the actual code
            }

            if (typeof code !== "string" || code.trim() === "") {
                console.warn("Empty or invalid code provided:", code);
                code = "// No code provided"; // Default fallback for empty code
            }

            try {
                return hljs.highlight(code, { language: validLanguage }).value;
            } catch (error) {
                console.error("Highlighting error:", error);
                return hljs.highlightAuto(code).value; // Fallback to auto-detection
            }
        },
        breaks: true,
    });



    function addCopyListeners() {
        document.querySelectorAll('.copy-button').forEach(button => {
            button.addEventListener('click', async function() {
                const codeBlock = this.nextElementSibling.querySelector('code');
                const textToCopy = codeBlock.innerText;
                try {
                    await navigator.clipboard.writeText(textToCopy);
                    this.textContent = 'Copied!';
                    setTimeout(() => {
                        this.textContent = 'Copy';
                    }, 3000);
                } catch (err) {
                    console.error('Failed to copy: ', err);
                }
            });
        });
    }

    async function generateImage(data, useFlux = false) {
        const url = useFlux ? "https://api-inference.huggingface.co/models/black-forest-labs/FLUX.1-dev" :
        "https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-3.5-large";
        //console.log(url);
        try {
            const response = await fetch(url, {
                headers: {
                    Authorization: `Bearer ${h_faceKey}`,
                    "Content-Type": "application/json",
                },
                method: "POST",
                body: JSON.stringify(data),
            });
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        } catch (error) {
            console.error("Image generation error:", error);
            return null;
        }
    }

    function escapeHTML(unsafe) {
        console.log(typeof(unsafe));
        if (typeof unsafe !== 'string') {
            return '';
        }
        return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    async function classifyText(text) {
        const isImageRequest = text.startsWith("/image");
        const escapedText = escapeHTML(text);

        // Display user message
        const userMessageId = `msg_${Math.random().toString(34).substring(3, 9)}`;
        const copyButtonId = `copy-button-${Math.random().toString(36).substring(5, 9)}`;
        const userMessage = document.createElement("div");
        userMessage.innerHTML = `
        <div data-id="${userMessageId}" class="relative bg-gradient-to-tl from-sky-600 to-fuchsia-800 dark:from-purple-700 dark:to-pink-700 text-white dark:text-gray-100 rounded-lg p-2 font-normal dark:shadow-cyan-500/50  md:p-3 shadow-md max-w-full md:lg:max-w-4xl lg:max-w-5xl">
        <p class="whitespace-pre-wrap break-words max-w-xl md:max-w-2xl lg:max-w-3xl">${escapedText}</p>
        <button id="${copyButtonId}" class="user-copy-button absolute rounded-md px-2 py-2 right-1 bottom-0.5 bg-gradient-to-r from-indigo-400 to-pink-400 dark:from-gray-700 dark:to-gray-900 hover:bg-indigo-200 dark:hover:bg-gray-600 text-white dark:text-gray-100 rounded-lg p-2 font-semibold border border-2 cursor-pointer opacity-80 hover:opacity-50">
        Copy
        </button>
        </div>`;
        userMessage.classList.add("flex", "justify-end", "mb-4", "overflow-wrap");
        chatArea.appendChild(userMessage);
        implementUserCopy();
        chatArea.scrollTop = chatArea.scrollHeight;
        if (!isImageRequest) {
            conversationHistory.push({ role: "user", content: text });
        }

        if (isImageRequest) {
            const imageData = { inputs: text.replace("/image", "").trim() };
            const imageId = `image_${Math.random().toString(36).substring(2, 7)}`;
            const loadingMessage = document.createElement("div");
            loadingMessage.innerHTML = `
            <div id="${imageId}" class="w-fit bg-gray-200 text-gray-800 dark:bg-gradient-to-tl dark:from-teal-700 dark:to-cyan-700 dark:text-gray-100 rounded-lg p-2 font-normal shadow-lg dark:shadow-blue-500 max-w-3xl mb-4">
            <div class="space-x-2 flex">
            <div class="bg-blue-500 dark:bg-cyan-400 w-2 h-2 xl:w-4 xl:h-4 rounded-full animate-bounce"></div>
            <div class="bg-blue-400 dark:bg-sky-400 w-2 h-2  xl:w-4 xl:h-4 rounded-full animate-bounce-200"></div>
            <div class="bg-rose-700 dark:bg-orange-700 w-2 h-2  xl:w-4 xl:h-4 rounded-full animate-bounce-400"></div>
            <span class="text-sm text-gray-50">0s</span>
            </div>
            </div>
            `;
            chatArea.appendChild(loadingMessage);
            chatArea.scrollTop = chatArea.scrollHeight;
            let secondsElapsed = 0;
            const timerInterval = setInterval(() => {
                secondsElapsed++;
                loadingMessage.querySelector('span').textContent = `${secondsElapsed}s`;
            }, 1000);

            const useFlux = document.getElementById('CModel').checked;
            const imageUrl = await generateImage(imageData, useFlux);
            clearInterval(timerInterval);

            if (imageUrl) {
                const imageContainer = document.createElement("div");
                const imageElement = document.createElement("img");
                imageElement.src = imageUrl;
                imageElement.classList.add("rounded-lg", "shadow-lg", "mt-4", "max-w-xs", "cursor-pointer");
                imageElement.addEventListener("click", () => {
                    if (imageElement.requestFullscreen) {
                        imageElement.requestFullscreen();
                    } else if (imageElement.webkitRequestFullscreen) {
                        imageElement.webkitRequestFullscreen();
                    } else if (imageElement.msRequestFullscreen) {
                        imageElement.msRequestFullscreen();
                    }
                });

                const downloadButtonContainer = document.createElement("button");
                downloadButtonContainer.classList.add("text-white", "rounded-b-md", "bg-gradient-to-r", "from-blue-500", "to-purple-500", "hover:from-blue-600", "hover:to-purple-600", "font-semibold", "py-2", "px-4", "inline-block", "focus:outline-none", "shadow-md", "w-fit", "h-fit", "mt-0", "ml-2");

                const downloadButton = document.createElement("a");
                downloadButton.href = imageUrl;
                downloadButton.download = "generated_image.png";
                downloadButton.classList.add("text-white", "no-underline");
                downloadButton.innerText = "Download Image";

                downloadButtonContainer.appendChild(downloadButton);
                imageContainer.appendChild(imageElement);
                imageContainer.appendChild(downloadButtonContainer);

                loadingMessage.innerHTML = '';
                loadingMessage.appendChild(imageContainer);
            } else {
                loadingMessage.textContent = 'Image generation failed';
            }
        } else {
            const mode = modeSelect.value;
            let model = "Qwen/Qwen2.5-72B-Instruct";
            if (mode === 'Coding mode') {
                model = "Qwen/Qwen2.5-Coder-32B-Instruct";
            }

            const aiMessage = document.createElement("div");
            aiMessage.innerHTML = `
            <div class="bg-gray-200 text-gray-800 dark:bg-gradient-to-tl dark:from-teal-700 dark:to-cyan-700 dark:text-black rounded-lg p-2 font-normal shadow-lg dark:shadow-blue-500 p-3 max-w-3xl mb-4">
            <div class="loader space-x-2 flex">
            <div class="bg-blue-500 dark:bg-cyan-400 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce"></div>
            <div class="bg-blue-400 dark:bg-sky-400 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce-200"></div>
            <div class="bg-rose-700 dark:bg-orange-700 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce-400"></div>
            </div>
            </div>`;

            const aiMessageUId = `msg_${Math.random().toString(34).substring(3,9)}`;
            aiMessage.classList.add(aiMessageUId, "flex", "justify-start", "mb-4");
            chatArea.appendChild(aiMessage);
            chatArea.scrollTop = chatArea.scrollHeight;

            try {
                const stream = client.chatCompletionStream({
                    model: model,
                    messages: conversationHistory,
                    max_tokens:10000
                });

                let output = "";
                for await (const chunk of stream) {
                    if (chunk?.choices?.length > 0) {
                        output += chunk.choices[0].delta.content;
                        // Update innerHTML with marked output
                        aiMessage.innerHTML = `<div class="${aiMessageUId} bg-gray-200 text-gray-800 dark:bg-gradient-to-tl dark:from-blue-500 dark:to-sky-00 dark:text-black rounded-lg p-2 font-normal shadow-lg dark:shadow-blue-500 p-3 max-w-full md:lg:max-w-5xl lg:max-w-6xl mb-6">${marked(output)}</div>`;

                        // Add styles to code blocks
                        aiMessage.querySelectorAll('pre').forEach(pre => {
                            pre.querySelectorAll('code').forEach(code => {
                                code.classList.add('dark:bg-green-200');
                                code.parentElement.classList.add('dark:border-gray-100');
                            });
                        });

                        addCopyListeners(); // Assuming this function adds copy functionality to code blocks
                    }
                    renderMathJax();
                }

                // Store conversation history
                conversationHistory.push({ role: "assistant", content: output });

            } catch (error) {
                console.error(error);
                // Handle request error appropriately
                handleRequestError(error, conversationHistory);
            }
        }

    }

    // Function to ensure MathJax renders dynamically injected content
    function renderMathJax() {
        if (window.MathJax) {
            MathJax.typesetPromise()
            .then(() => console.log("MathJax rendering complete"))
            .catch((err) => console.error("MathJax rendering failed:", err));
        } else {
            console.error("MathJax is not loaded or available.");
        }
    }

    function handleRequestError(error, conversationHistory) {
        try{
            console.log(`${error}Intercepted`);
            const errorContainer = document.getElementById('errorContainer');
            const errorArea = document.getElementById('errorArea');
            const closeModal = document.getElementById('closeEModal');
            const retry = document.getElementById('retry');
            const lastMessage = conversationHistory.slice(-1)[0].content;

            closeModal.addEventListener('click', () => errorContainer.classList.add('hidden'));

            retry.addEventListener('click', () => {
                // Handle retry action
                classifyText(lastMessage);
                console.log('Retry action triggered with:', conversationHistory);
                errorContainer.classList.add('hidden');
            });

            // Function to show the modal with an error message
            function showError() {
                errorContainer.classList.remove('hidden');
                errorArea.textContent = error;
                conversationHistory.pop();
            }

            showError();

        } catch (err){
            console.error(err);
        }
    }


    function implementUserCopy() {
        document.querySelectorAll('.user-copy-button').forEach(button => {
            const buttonParent = button.parentElement;
            const textBlock = buttonParent.querySelector('p');

            if (textBlock && textBlock.innerHTML.length < 50) {
                button.style.display = 'none';
            }

            button.addEventListener('click', async function() {
                const textToCopy = textBlock.innerText;

                if (textToCopy.length >= 50) {
                    try {
                        await navigator.clipboard.writeText(textToCopy);
                        this.textContent = 'Copied!';
                        setTimeout(() => {
                            this.textContent = 'Copy';
                        }, 3000);
                    } catch (err) {
                        console.error('Failed to copy: ', err);
                    }
                }
            });
        });
    }

    sendBtn.addEventListener("click", () => {
        const inputText = userInput.value.trim();
        if (inputText) {
            userInput.value = "";
            classifyText(inputText);
            document.getElementById('suggestions').classList.add('hidden')
        }
    });

    userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
            const inputText = userInput.value.trim();
            if (inputText) {
                userInput.value = "";
                classifyText(inputText);
                document.getElementById('suggestions').classList.add('hidden')
            }
        }
    });

}
