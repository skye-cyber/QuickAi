import { HfInference } from "@huggingface/inference";
import { marked } from "marked";
import hljs from 'highlight.js';
import { get_key } from './Pcrypto.js';

let h_faceKey = null; // Define h_faceKey globally

window.electron.getEnv().then(env => {
    const encryptedOBJ = {
        iv: env.IV,
        encryptedData: env.API_OBJ
    };

    const SKEY = env.SKEY;
    const keyObject = get_key(encryptedOBJ, SKEY);

    keyObject.then(result => {
        h_faceKey = result;
        const client = new HfInference(h_faceKey);
        initChat(client);
    }).catch(error => {
        console.error("Error:", error);
    });
});

function initChat(client) {
    const chatArea = document.getElementById("chatArea");
    const userInput = document.getElementById("userInput");
    const sendBtn = document.getElementById("sendBtn");
    const modeSelect = document.getElementById('mode');
    const AutoScroll = document.getElementById("AutoScroll");
    let check = false;

    // Custom instructions
    const customInstructions = `
    Your name is QuickAi. You are deployed in a cross-platform application built on Electron by Wambua, also known as Skye. He is an undergraduate software developer at Kirinyaga University in Kenya. He has mastered many digital technologies, including but not limited to: HTML5, CSS3, JavaScript, TailwindCSS, Node.js, Python, Django, Electron, Git, MySQL/MariaDB, Markdown, GIMP (GNU Image Manipulation Program), scikit-learn, and OpenCV. You can find him on his [GitHub Profile](https://github.com/skye-cyber) or [Huggingface Profile](https://huggingface.co/skye-waves).

    Your primary goal is to assist the user in all their needs. You should be brief and direct to the point based on the user's needs. You are required to use TailwindCSS for styling unless the user requests otherwise.

    Definition of terms:
    - Language identifier: Shall include the language and both the opening and closing backticks, for example, \`\`\`html\`\`\`.

    When interacting with the user:
    - You are allowed but not required to begin by introducing yourself and optionally mentioning your deployer/creator, goal unless you've done so previously. However, if the user starts the interaction by directly diving into the problem/question at hand, you can skip the introduction.
    - Further information about yourself or your creator (Wambua) should only be revealed when explicitly requested for.
    - If the user needs to visualize/preview diagrams or generate images, inform them that you cannot directly generate diagrams or images. Instead, come up with a query describing what you or the user would wish to visualize, and instruct them to paste this prompt in the text area starting with '/image' to generate the image.
    - If it is not clear what image the user wants to generate, ask them for a description of what they want, and then restructure it to form a clear prompt for the user.
    - For diagrams, if the user is not satisfied with the image generation method, offer to provide them with DOT code and instructions on how to use it. You can also inform them to activate the checkbox with the text 'Use Flux 4 Image Generation' appearing at the top of the chat area, which will use a different approach to generate the image or diagram.
    - In a conversation, ascertain the relationship between previous conversations and the current interaction.
    - Engage the user by asking questions. The choice of how to do this is at your discretion.
    - Use colors that are more visible than light gray, such as deep gray or other contrasting colors.

    For drawing tables:
    - The default table preview/visualization is HTML except when the user requests otherwise.
    - For table previews, no code should be shown.
    - For HTML tables, write the HTML code without the '\`\`\`html\`\`\`' language identifier. For Markdown tables, omit the '\`\`\`markdown\`\`\`' identifier.
    - Use CSS styling to make the table visually appealing, avoiding TailwindCSS.
    - Ensure the table has a more visible outer border to distinguish it from the rest of the content.
    - For prompts starting with "create a table" or "draw a table," the goal is to provide a visually appealing table unless otherwise instructed.
    - Use headings, subheadings, and bullet points to make the content more scannable.
    - Add images or icons or SVGs to visually break up the text and make it more engaging. You can do this by following the same approach used in previews, e.g., "## <span style='display:flex;'>Hello <svg>svg goes here</svg></span>".
    - You are advised to use visually appealing tables to explain concepts in cases where the user prefers so or in where concepts are better understood in table form.
    - Use HTML to align text where you want, in which case you will remove the language identifier, all HTML resources are at your disposal, so make use of it efficiently as you deem fit, provided that omitting the language identifier (html) is not forgotten.
    - When generating HTML codes in cases where you are not using TailwindCSS, you can use the concept of tables mentioned earlier to show the user how the result will look, this you can do by writing the same HTML code but omitting the language identifier '\`\`\`html\`\`\`'.
    - You can use HTML to make your response more elegant and appealing to the user, in which case you would omit the HTML identifier and use inline CSS for styling.
    - Use different text and background colors that contrast well with lightgray and skyblue backgrounds.

    Color choices:
    - Alway use CSS with both dark and light color for compartibility.
    - Dark theme background color is lightgray.
    - Light theme background color is a gradient from-blue-500 to-sky-500.
    - Use color gradient for even more elegance.

    - Important:
    1. Always remove the language identifier (e.g., \`\`\`\`html\`\`\`) when providing previews, tables, svgs, icons, diagrams, etc.
    2. Strictly adhere to decisions like size, color, placement, and alignment choices.
    3. Using the same alignment throughout unless necessary might become monotonous to the user.
    4. By default, all your responses are rendered in dark text. Use HTML to change that as you deem fit.
    5. By default, all your responses are aligned to the left. Use HTML to change that as needed, for example, <h1 style="text-align: Center;">Content goes here</h1> for heading 1 center placement.
    6. Use flex style to align related content for example a div enclosing svg and its text should use flex style.
    7. TailwindCSS shall not be used in previews or in any instance where the goal is to provide visual appeal, such as when the language identifier has been removed.
    8. Always double check your response to ensure it adheres to the guidelines.
    9. In color choices you are not restricted to any colors as long as the you use both light and dark them variant that a well visible in the respective background color as informed earlier.
    10. All links should open in new tabs meaning they should have traget as _blank and a title describing their purpose.
    11. All the text styling inside html elements should be CSS. For example instead of **Text** you would use html bold attribute.
    12. Bullet points should be indented inwards and have different color from their parent.
    13. Major headings/titles should have a different color other than black.
    14. If users need to share or chat by providing images/visual data, they can do so by selecting vision model at the top left menu, then they can upload files.
    `;

    let conversationHistory = [{ role: "system", content: customInstructions }];

    // Initialize highlight.js
    hljs.configure({ ignoreUnescapedHTML: true });

    // Custom renderer for syntax highlighting
    const renderer = new marked.Renderer();
    renderer.code = function (code, language) {
        // Handle case where `code` is an object
        const validLanguage = code.lang || 'plaintext';
        console.log(`Language: ${validLanguage}`);
        if (typeof code === "object" && code.text !== undefined) {
            code = code.text; // Extract the actual code
        }

        if (typeof code !== "string" || code.trim() === "") {
            console.warn("Empty or invalid code provided:", code);
            code = "// No code provided"; // Default fallback for empty code

        }

        // Highlight the code
        let highlighted;
        try {
            highlighted = hljs.highlight(code, { language: validLanguage }).value;
        } catch (error) {
            console.error("Highlighting error:", error);
            highlighted = hljs.highlightAuto(code).value; // Fallback to auto-detection
        }

        // Generate unique ID for the copy button
        const copyButtonId = `copy-button-${Math.random().toString(36).substring(2, 9)}`;

        return `
        <div class="relative my-auto p-2 border border-gray-300 dark:border-gray-900 bg-white dark:bg-gray-800 rounded-md max-w-full">
        <p class="code-language absolute rounded-md left-2 top-0.5 dark:text-gray-700 dark:text-white rounded-lg font-normal text-sm cursor-pointer opacity-80 hover:opacity-50">
        ${validLanguage}
        </p>
        <button id="${copyButtonId}" class="copy-button absolute rounded-md px-2 py-2 right-2 top-2 bg-gradient-to-r from-sky-800 to-purple-600 hover:bg-blue-400 text-white border border-2 cursor-pointer opacity-80 hover:opacity-50 dark:bg-gray-800">
        Copy
        </button>
        <pre class="rounded-md dark:bg-gray-700">
        <code class="hljs ${validLanguage} dark:bg-gray-950">${highlighted}</code>
        </pre>
        </div>
        `;
    };

    // Configure marked.js
    marked.setOptions({
        renderer: renderer,
        highlight: function (code, lang) {
            // Handle case where `code` is an object
            const validLanguage = code.lang || 'plaintext';
            if (typeof code === "object" && code.text !== undefined) {
                code = code.text; // Extract the actual code
            }

            if (typeof code !== "string" || code.trim() === "") {
                console.warn("Empty or invalid code provided:", code);
                code = "// No code provided"; // Default fallback for empty code
            }

            try {
                return hljs.highlight(code, { language: validLanguage }).value;
            } catch (error) {
                console.error("Highlighting error:", error);
                return hljs.highlightAuto(code).value; // Fallback to auto-detection
            }
        },
        breaks: true,
    });


    function addCopyListeners() {
        document.querySelectorAll('.copy-button').forEach(button => {
            button.addEventListener('click', async function() {
                const codeBlock = this.nextElementSibling.querySelector('code');
                const textToCopy = codeBlock.innerText;
                try {
                    await navigator.clipboard.writeText(textToCopy);
                    this.textContent = 'Copied!';
                    setTimeout(() => {
                        this.textContent = 'Copy';
                    }, 3000);
                } catch (err) {
                    console.error('Failed to copy: ', err);
                }
            });
        });
    }

    async function generateImage(data, useFlux = false) {
        const url = useFlux ? "https://api-inference.huggingface.co/models/black-forest-labs/FLUX.1-dev" :
        "https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-3.5-large";
        //console.log(url);
        try {
            const response = await fetch(url, {
                headers: {
                    Authorization: `Bearer ${h_faceKey}`,
                    "Content-Type": "application/json",
                },
                method: "POST",
                body: JSON.stringify(data),
            });
            const blob = await response.blob();
            return URL.createObjectURL(blob);
        } catch (error) {
            console.error("Image generation error:", error);
            return null;
        }
    }

    function escapeHTML(unsafe) {
        if (typeof unsafe !== 'string') {
            return '';
        }
        return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    async function classifyText(text) {
        const isImageRequest = text.startsWith("/image");
        const escapedText = escapeHTML(text);
        const mode = modeSelect.value;

        // Display user message
        const userMessageId = `msg_${Math.random().toString(34).substring(3, 9)}`;
        const copyButtonId = `copy-button-${Math.random().toString(36).substring(5, 9)}`;
        const userMessage = document.createElement("div");
        if (mode === "Vision"){
            VisionChat(text=text)

        } else {
            userMessage.innerHTML = `
            <div data-id="${userMessageId}" class="relative bg-gradient-to-tl from-sky-600 to-fuchsia-800 dark:from-purple-700 dark:to-pink-700 text-white dark:text-gray-100 rounded-lg p-2 font-normal dark:shadow-cyan-500/50  md:p-3 shadow-md w-fit max-w-full lg:max-w-5xl">
                <p class="whitespace-pre-wrap break-words max-w-xl md:max-w-2xl lg:max-w-3xl">${escapedText}</p>
                <button id="${copyButtonId}" class="user-copy-button absolute rounded-md px-2 py-2 right-1 bottom-0.5 bg-gradient-to-r from-indigo-400 to-pink-400 dark:from-gray-700 dark:to-gray-900 hover:bg-indigo-200 dark:hover:bg-gray-600 text-white dark:text-gray-100 rounded-lg p-2 font-semibold border border-2 cursor-pointer opacity-40 hover:opacity-80">
            Copy
            </button>
            </div>
            `;

            userMessage.classList.add("flex", "justify-end", "mb-4", "overflow-wrap");
            chatArea.appendChild(userMessage);
            implementUserCopy();
            chatArea.scrollTop = chatArea.scrollHeight;
            if (!isImageRequest) {
                conversationHistory.push({ role: "user", content: text });
            }

            if (isImageRequest) {
                const imageData = { inputs: text.replace("/image", "").trim() };
                const imageId = `image_${Math.random().toString(36).substring(2, 7)}`;
                const loadingMessage = document.createElement("div");
                loadingMessage.innerHTML = `
                <div id="${imageId}" class="w-fit bg-gray-200 text-gray-800 dark:bg-gradient-to-tl dark:from-teal-700 dark:to-cyan-700 dark:text-gray-100 rounded-lg p-2 font-normal shadow-lg dark:shadow-blue-500 max-w-3xl mb-[7%] lg:mb-[5%]">
                <div class="space-x-2 flex">
                <div class="bg-blue-500 dark:bg-cyan-400 w-2 h-2 xl:w-3 xl:h-3 rounded-full animate-bounce"></div>
                <div class="bg-blue-400 dark:bg-sky-400 w-2 h-2  xl:w-3 xl:h-3 rounded-full animate-bounce-200"></div>
                <div class="bg-rose-700 dark:bg-orange-700 w-2 h-2  xl:w-3 xl:h-3 rounded-full animate-bounce-400"></div>
                <span class="text-sm text-gray-700 dark:text-gray-200">0s</span>
                </div>
                </div>
                `;
                chatArea.appendChild(loadingMessage);
                chatArea.scrollTop = chatArea.scrollHeight;
                let secondsElapsed = 0;
                const timerInterval = setInterval(() => {
                    secondsElapsed++;
                    loadingMessage.querySelector('span').textContent = `${secondsElapsed}s`;
                }, 1000);

                const useFlux = document.getElementById('CModel').checked;
                const imageUrl = await generateImage(imageData, useFlux);
                clearInterval(timerInterval);

                if (imageUrl) {
                    const imageContainer = document.createElement("div");
                    imageContainer.classList.add("relative", "mb-[5%]")
                    const imageElement = document.createElement("img");
                    imageElement.src = imageUrl;
                    imageElement.classList.add("rounded-lg", "shadow-lg", "mt-4", "max-w-xs", "cursor-pointer");
                    imageElement.addEventListener("click", () => {
                        if (imageElement.requestFullscreen) {
                            imageElement.requestFullscreen();
                        } else if (imageElement.webkitRequestFullscreen) {
                            imageElement.webkitRequestFullscreen();
                        } else if (imageElement.msRequestFullscreen) {
                            imageElement.msRequestFullscreen();
                        }
                    });

                    const downloadButtonContainer = document.createElement("button");
                    downloadButtonContainer.classList.add("absolute", "flex", "items-center", "text-white", "rounded-bl-md", "bg-gradient-to-r", "from-blue-500", "to-purple-500", "hover:from-blue-600", "hover:to-purple-600", "font-semibold", "py-2", "px-4", "focus:outline-none", "shadow-md", "w-fit", "h-fit", "bottom-0", "left-0", "opacity-60", "hover:opacity-100");

                    const downloadButton = document.createElement("a");
                    downloadButton.classList.add("flex", "items-center", "text-white", "no-underline");
                    downloadButton.href = imageUrl;
                    downloadButton.download = "generated_image.png";
                    downloadButton.innerHTML = `
                    <div class="flex items-center">
                    <span>Download</span>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="ml-2">
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M12 21C11.7348 21 11.4804 20.8946 11.2929 20.7071L4.29289 13.7071C3.90237 13.3166 3.90237 12.6834 4.29289 12.2929C4.68342 11.9024 5.31658 11.9024 5.70711 12.2929L11 17.5858V4C11 3.44772 11.4477 3 12 3C12.5523 3 13 3.44772 13 4V17.5858L18.2929 12.2929C18.6834 11.9024 19.3166 11.9024 19.7071 12.2929C20.0976 12.6834 20.0976 13.3166 19.7071 13.7071L12.7071 20.7071C12.5196 20.8946 12.2652 21 12 21Z" fill="currentColor"></path>
                    </svg>
                    </div>
                    `;

                    downloadButtonContainer.appendChild(downloadButton);
                    document.body.appendChild(downloadButtonContainer);

                    downloadButtonContainer.appendChild(downloadButton);
                    imageContainer.appendChild(imageElement);
                    imageContainer.appendChild(downloadButtonContainer);

                    loadingMessage.innerHTML = '';
                    loadingMessage.appendChild(imageContainer);
                } else {
                    loadingMessage.innerHTML = `
                    <div id="${imageId}" class="w-fit bg-red-400 text-gray-950 dark:bg-rose-500 rounded-lg p-2 font-normal shadow-lg dark:shadow-red-500 max-w-3xl mb-[5%]">
                    <span class="text-sm text-gray-950 dark:text-black">Could not Process request!⚠️</span>
                    </div>
                    `;
                }
            } else {
                let model = "Qwen/Qwen2.5-72B-Instruct";
                if (mode === 'Coding mode') {
                    model = "Qwen/Qwen2.5-Coder-32B-Instruct";
                }

                const aiMessage = document.createElement("div");
                aiMessage.innerHTML = `
                <div id="loader-parent" class="bg-gray-200 text-gray-800 dark:bg-gradient-to-tl dark:from-teal-700 dark:to-cyan-700 dark:text-black rounded-lg p-2 shadow-lg dark:shadow-blue-500 p-3 max-w-3xl">
                <div class="loader space-x-2 flex">
                <div class="bg-blue-500 dark:bg-cyan-400 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce"></div>
                <div class="bg-blue-400 dark:bg-sky-400 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce-200"></div>
                <div class="bg-rose-700 dark:bg-orange-700 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce-400"></div>
                </div>
                </div>`;

                const aiMessageUId = `msg_${Math.random().toString(30).substring(3,9)}`;
                aiMessage.classList.add("flex", "justify-start", "mb-[6%]", "overflow-wrap");
                chatArea.appendChild(aiMessage);
                AutoScroll.checked ? scrollToBottom(chatArea) : null;

                try {
                    const stream = client.chatCompletionStream({
                        model: model,
                        messages: conversationHistory,
                        max_tokens:5000
                    });

                    let output = "";
                    for await (const chunk of stream) {
                        /*
                        if (chunk?.choices?.length > 0) {
                            output += chunk.choices[0].delta.content;*/
                        const choice = chunk?.choices?.[0];
                        if (choice?.delta?.content) {
                            output += choice.delta.content;
                            // Update innerHTML with marked output
                            aiMessage.innerHTML = `
                            <section class="relative w-fit max-w-full lg:max-w-6xl">
                                <div class="${aiMessageUId} bg-gray-200 text-gray-800 dark:bg-gradient-to-tl dark:from-blue-500 dark:to-sky-500 dark:text-black rounded-lg shadow-md dark:shadow-blue-500 px-4 mb-6 pt-2 pb-4 w-fit max-w-full lg:max-w-6xl">${marked(output)}
                                </div>
                                <section class="options flex absolute bottom-0 left-0 space-x-4 cursor-pointer">
                                    <div class="opacity-70 hover:opacity-100 p-1 border-none" id="exportButton" onclick="toggleExportOptions(this);" title="Export">
                                        <svg class="fill-rose-700 dark:fill-gray-700 text-gray-600 bg-white w-6 h-6 rounded-full" viewBox="0 0 24 24">
                                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                                        </svg>
                                    </div>
                                    <div class="rounded-lg p-1 opacity-70 cursor-pointer" aria-label="Copy" title="Copy" id="copy-all" onclick="CopyAll('.${aiMessageUId}');">
                                        <svg class="w-5 md:w-6 h-5 md:h-6" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <path class="fill-black dark:fill-pink-300" fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15    19V10C15 9.44772 14.5523 9 14 9H5Z"></path>
                                        </svg>
                                    </div>
                                </section>

                                <div id="exportOptions" class="hidden block absolute bottom-6 left-0 bg-white dark:bg-gray-800 p-2 rounded shadow-md z-50 transition-300">

                                    <ul class="list-none p-0">
                                        <li class="mb-2">
                                        <a href=""  class="text-blue-500 dark:text-blue-400" onclick="HTML2Pdf(event, '.${aiMessageUId}')">1. Export to PDF</svg></a>
                                        </li>
                                        <li class="mb-2">
                                            <a href=""  class="text-blue-500 dark:text-blue-400" onclick="HTML2Jpg(event, '.${aiMessageUId}')">2. Export to JPG</a>
                                        </li>
                                        <li>
                                            <a href="" class="text-blue-500 dark:text-blue-400" onclick="HTML2Word(event, '.${aiMessageUId}')">3. Export to DOCX</a>
                                        </li>
                                        <li>
                                            <a href="" class="text-blue-500 dark:text-blue-400 decoration-underline" onclick="SuperHTML2Word(event, '.${aiMessageUId}')">4. Word Export Advance</a>
                                        </li>
                                    </ul>
                                </div>
                            </section>
                            `;
                            AutoScroll.checked ? scrollToBottom(chatArea) : null;
                            addCopyListeners(); // Assuming this function adds copy functionality to code blocks
                            // Debounce MathJax rendering to avoid freezing
                            debounceRenderMathJax(aiMessageUId);
                        }

                    }

                    if (check === false) {
                        addUtilityScript();
                        check = true;
                    }

                    // Store conversation history
                    conversationHistory.push({ role: "assistant", content: output });

                } catch (error) {
                    console.log(error);
                    handleRequestError(error, userMessage, aiMessage, conversationHistory);

                }
            }
        }

    }

    // Listen for the imageLoaded event
    document.addEventListener('imageLoaded', function(event) {
        const fileDataUrl = event.detail.fileDataUrl;
        const text = event.detail.text;
        const fileType = event.detail.fileType
        VisionChat(text, fileType, fileDataUrl);
    });

//initialize system Instructions
let VisionHistory = [];
const VisionSystem = `
    Your name is QuickAi. You are deployed in a cross-platform application built on Electron by Wambua, also known as Skye. He is an undergraduate software developer at Kirinyaga University in Kenya. He has mastered many digital technologies, including but not limited to: HTML5, CSS3, JavaScript, TailwindCSS, Node.js, Python, Django, Electron, Git, MySQL/MariaDB, Markdown, GIMP (GNU Image Manipulation Program), scikit-learn, and OpenCV. You can find him on his [GitHub Profile](https://github.com/skye-cyber) or [Huggingface Profile](https://huggingface.co/skye-waves).

    Your primary goal is to assist the user in all their needs. You should be brief and direct to the point based on the user's needs. You are required to use TailwindCSS for styling unless the user requests otherwise.
    When interacting with the user:
    - You are allowed but not required to begin by introducing yourself and optionally mentioning your deployer/creator, goal unless you've done so previously. However, if the user starts the interaction by directly diving into the problem/question at hand, you can skip the introduction.
    - Further information about yourself or your creator (Wambua) should only be revealed when explicitly requested for.
`;
VisionHistory.push({
    role: "system",
    content: [
        {
            type: "text",
            text: VisionSystem,
        },
    ],
});

async function VisionChat(text, fileType, fileDataUrl = null) {
    console.log(fileDataUrl)
    //console.log("Initial VisionHistory:", JSON.stringify(VisionHistory, null, 2));
    //switch to vission model
    modeSelect.value = "Vision"
    // Determine the content based on fileDataUrl
    let userContent;
    if (fileDataUrl) {
        console.log("Image url present", fileDataUrl);
        if (fileType == "image") {
            userContent = [
                {
                    type: "text",
                    text: text,
                },
                {
                    type: "image_url",
                    image_url: {
                        url: fileDataUrl,
                    },
                },
            ];
        }
        else if (fileType == "document") {
            userContent = [
                {
                    type: "text",
                    text: text,
                },
                {
                    type: "file_url",
                    file_url: {
                        url: fileDataUrl,
                    },
                },
            ];
        }
    } else {
        console.log("Url not found");
        userContent = [
            {
                type: "text",
                text: text,
            },
        ];
    }

    // Add user message to VisionHistory
    VisionHistory.push({
        role: "user",
        content: userContent,
    });

    //console.log("Updated VisionHistory:", JSON.stringify(VisionHistory, null, 2));

    console.log(userContent)
    // Store the last message for retry purposes
    const lastMessage = userContent;

    // Add user message to chat
    const userMessage = addUserMessage(text, fileType, fileDataUrl);
    const VisionMessage = document.createElement("div");
    const VisionMessageUId = `msg_${Math.random().toString(30).substring(3, 9)}`;
    VisionMessage.classList.add("flex", "justify-start", "mb-[6%]", "overflow-wrap");
    chatArea.appendChild(VisionMessage);

    // Add loading animation
    VisionMessage.innerHTML = `
    <div id="loader-parent" class="bg-gray-200 dark:bg-slate-800 text-gray-800 dark:text-black rounded-lg p-2 shadow-lg dark:shadow-md dark:shadow-blue-500 p-3 max-w-3xl">
    <div class="loader space-x-2 flex">
    <div class="bg-blue-500 dark:bg-cyan-400 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce"></div>
    <div class="bg-blue-400 dark:bg-sky-400 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce-200"></div>
    <div class="bg-rose-700 dark:bg-orange-700 w-2 h-2 lg:w-3 lg:h-3 rounded-full animate-bounce-400"></div>
    </div>
    </div>
    `;

    try {
        const visionstream = client.chatCompletionStream({
            model: "meta-llama/Llama-3.2-11B-Vision-Instruct",
            messages: VisionHistory,
            max_tokens: 2000,
        });

        let visionMs = "";
        for await (const chunk of visionstream) {
            const choice = chunk?.choices?.[0];
            if (choice?.delta?.content) {
                visionMs += choice.delta.content;
                VisionMessage.innerHTML = `
                <section class="relative w-fit max-w-full lg:max-w-6xl">
                    <div class="${VisionMessageUId} bg-gray-200 text-gray-800 dark:bg-gradient-to-tl dark:from-blue-500 dark:to-sky-500 dark:text-black rounded-lg shadow-md dark:shadow-blue-500 px-4 mb-6 pt-2 pb-4 w-fit max-w-full md:max lg:max-w-6xl">${marked(visionMs)}
                    </div>
                    <section class="options flex absolute bottom-0 left-0 space-x-4 cursor-pointer">
                        <div class="opacity-70 hover:opacity-100 p-1 border-none" id="exportButton" onclick="toggleExportOptions(this);" title="Export">
                            <svg class="fill-rose-700 dark:fill-gray-700 text-gray-600 bg-white w-6 h-6 rounded-full" viewBox="0 0 24 24">
                                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                            </svg>
                        </div>
                        <div class="rounded-lg p-1 opacity-70 cursor-pointer" aria-label="Copy" title="Copy" id="copy-all" onclick="CopyAll('.${VisionMessageUId}');">
                            <svg class="w-5 md:w-6 h-5 md:h-6" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path class="fill-black dark:fill-pink-300" fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z"></path>
                            </svg>
                        </div>
                    </section>

                    <div id="exportOptions" class="hidden block absolute bottom-6 left-0 bg-white dark:bg-gray-800 p-2 rounded shadow-md z-50 transition-300">

                        <ul class="list-none p-0">
                            <li class="mb-2">
                                <a href="" class="text-blue-500 dark:text-blue-400" onclick="HTML2Pdf(event, '.${VisionMessageUId}')">1. Export to PDF</a>
                            </li>
                            <li class="mb-2">
                                <a href="" class="text-blue-500 dark:text-blue-400" onclick="HTML2Jpg(event, '.${VisionMessageUId}')">2. Export to JPG</a>
                            </li>
                            <li>
                                <a href="" class="text-blue-500 dark:text-blue-400" onclick="HTML2Word(event, '.${VisionMessageUId}')">3. Export to DOCX</a>
                            </li>
                            <li>
                                <a href="" class="text-blue-500 dark:text-blue-400 decoration-underline" onclick="SuperHTML2Word(event, '.${VisionMessageUId}')">4. Word Export Advance</a>
                            </li>
                        </ul>
                    </div>
                </section>
                `;

                AutoScroll.checked ? scrollToBottom(chatArea) : null;
                addCopyListeners();
                // Debounce MathJax rendering to avoid freezing
                debounceRenderMathJax(aiMessageUId);
            }
        }

        VisionHistory.push({ role: "assistant", content: [{ type: "text", text: visionMs }] });
        //console.log("Final VisionHistory:", JSON.stringify(VisionHistory, null, 2));

    } catch (error) {
        console.log("Error caught:", error);
        // Get elements for error modal
        console.log(lastMessage)
        const errorContainer = document.getElementById('errorContainer');
        const errorArea = document.getElementById('errorArea');
        const closeModal = document.getElementById('closeEModal');
        const retry = document.getElementById('retry');

        // Function to show the modal with an error message
        function showError() {
            errorContainer.classList.remove('hidden');
            errorArea.textContent = "An error occurred during response. Retry?";
            VisionHistory.pop(); // Remove the last conversation entry
        }

        // Remove existing event listeners before adding a new one
        retry.replaceWith(retry.cloneNode(true)); // Reset `retry` to remove all attached event listeners
        const newRetry = document.getElementById('retry'); // Re-fetch the newly cloned `retry` button

        // Retry action
        const retryHandler = () => {
            // Retry action with previous data
            if (lastMessage) {
                const textItem = lastMessage.find(item => item.type === "text");
                const text = textItem?.text;
                if (fileType == "image"){
                    const imageItem = lastMessage.find(item => item.type === "image_url");
                    var fileDataUrl = imageItem?.image_url?.url;
                    var fileType ="image"
                } else {
                    const imageItem = lastMessage.find(item => item.type === "file_url");
                    fileDataUrl = imageItem?.file_url?.url;
                    fileType ="document"
                }

                if (VisionMessage) VisionMessage.remove();
                if (userMessage) userMessage.remove();
                VisionChat(text, fileType, fileDataUrl);
            }

            errorContainer.classList.add('hidden');
        };

        newRetry.addEventListener('click', retryHandler);

        closeModal.addEventListener('click', () => {
            errorContainer.classList.add('hidden');
            if (VisionMessage) {
                if (VisionMessage.firstElementChild.id === "loader-parent") {
                    console.log("Loader present");
                    VisionMessage.remove();
                    userMessage.remove();
                    errorContainer.classList.add('hidden');
                }
            }
        });

        // Show error modal
        showError();
    }
}

    function addUserMessage(text, fileType, fileDataUrl) {
        const VisionUserMessageUId = `msg_${Math.random().toString(35).substring(2, 8)}`;
        const VisioncopyButtonId = `copy-button-${Math.random().toString(36).substring(5, 9)}`;
        const userMessage = document.createElement("div");
        userMessage.classList.add("flex", "justify-end", "mb-4");
        userMessage.innerHTML = `
        <div data-id="${VisionUserMessageUId}" class="relative bg-gradient-to-tl from-sky-600 to-fuchsia-800 dark:from-purple-700 dark:to-pink-700 text-white dark:text-gray-100 rounded-lg p-2 font-normal dark:shadow-cyan-500/50  md:p-3 shadow-md w-fit max-w-full lg:max-w-5xl">
            <button id="${VisioncopyButtonId}" class="Vision-user-copy-button absolute rounded-md px-2 py-2 right-1 bottom-0.5 bg-gradient-to-r from-indigo-400 to-pink-400 dark:from-gray-700 dark:to-gray-900 hover:bg-indigo-200 dark:hover:bg-gray-600 text-white dark:text-gray-100 rounded-lg p-2 font-semibold border border-2 cursor-pointer opacity-40 hover:opacity-80" onclick="CopyAll('.${VisionUserMessageUId}', this)">
                Copy
            </button>

            <div class="bg-blue-200 dark:bg-rose-400 text-gray-800 dark:text-white rounded-lg shadow-md px-4 py-2 w-fit max-w-full h-fit md:max-h-md lg:max-h-lg">
                <p class="${VisionUserMessageUId} whitespace-pre-wrap break-words max-w-xl md:max-w-2xl lg:max-w-3xl bg-blue-400 dark:bg-gradient-to-tr dark:from-pink-700 dark:via-cyan-800 dark:to-rose-600 p-1 mb-2 rounded-md">${escapeHTML(text)}</p>
                ${fileDataUrl && fileType === "image" ? `<img src="${fileDataUrl}" alt="Uploaded Image" class="rounded-md my-auto" />` : fileType === "document" ? `<svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16V4a2 2 0 0 1 2 2v12a2 2 0 0 0-2-2zm1-1h4v10h-4V4z"/>
                </svg>` : ""}
            </div>
        </div>
        `;
        chatArea.appendChild(userMessage);
        AutoScroll.checked ? scrollToBottom(chatArea) : null;
        copyBMan();
        return userMessage
    }

    function addUtilityScript() {
        console.log("Added Utility script");
        const script = document.createElement('script');
        script.src = 'src/renderer/js/_utility.js';
        script.async = true; // Optional: load the script asynchronously
        document.body.appendChild(script);
    }


    // Function to ensure MathJax renders dynamically injected content
    let renderTimeout;

    function debounceRenderMathJax(_currentclass, delay = 900) {
        //const targetElement = document.querySelector(_currentclass);
        if (renderTimeout) clearTimeout(renderTimeout);
        renderTimeout = setTimeout(() => {
            if (window.MathJax) {
                //MathJax.typesetPromise([document.querySelectorAll(_currentclass)])
                MathJax.typesetPromise(Array.from(document.querySelectorAll('[class^="msg_"], [class*=" msg_"]'))) //Apply mathjax to only the specified field
                .then(() => console.log("MathJax rendering complete"))
                .catch((err) => console.error("MathJax rendering error:", err.message));
            } else {
                console.error("MathJax is not loaded or available.");
            }
        }, delay);
    }


    function handleRequestError(error, userMessage, aiMessage, conversationHistory) {
        try {
            if (!error.message === "Failed to fetch" && !error.message === "network error") {
                console.log("History length:", conversationHistory.length);
                console.log('Error:', JSON.stringify(error, null, 2));
                console.log(error.details);
                console.log("History size:", conversationHistory.length * 1.024, "KB");
            } else {
                if (error.message === "[object Object]"){
                    removeFirstConversationPairs();
                }
                console.log(`Intercepted '${error}'`);
                console.log("Unknown error ->", error);
                console.log("History size:", conversationHistory.length * 1.024, "KB");
                const errorContainer = document.getElementById('errorContainer');
                const errorArea = document.getElementById('errorArea');
                const closeModal = document.getElementById('closeEModal');
                const retry = document.getElementById('retry');
                const lastMessage = conversationHistory.slice(-1)[0]?.content; // Safely access the last message

                // Remove existing event listeners before adding a new one
                const retryHandler = () => {
                    // Retry action
                    classifyText(lastMessage);

                    //console.log('Retry action triggered with:', lastMessage);
                    errorContainer.classList.add('hidden');
                    if (aiMessage) aiMessage.remove();
                    if (userMessage) userMessage.remove();
                };
                //window.retryHandler=retryHandler;
                retry.replaceWith(retry.cloneNode(true)); // Reset `retry` to remove all attached event listeners
                const newRetry = document.getElementById('retry'); // Re-fetch the newly cloned `retry` button
                newRetry.addEventListener('click', retryHandler);

                closeModal.addEventListener('click', () => {
                    errorContainer.classList.add('hidden')
                    if (aiMessage){
                        if (aiMessage.firstElementChild.id === "loader-parent"){
                            console.log("Removing loader")
                            aiMessage.remove();
                            userMessage.remove();
                            errorContainer.classList.add('hidden');
                        }
                    }
                });

                // Function to show the modal with an error message
                function showError() {
                    errorContainer.classList.remove('hidden');
                    errorArea.textContent = "An error occurred during response. Retry?";
                    conversationHistory.pop(); // Remove the last conversation entry
                }

                showError();
            }
        } catch (err) {
            console.error('Error handling request error:', err);
        }
    }

    function implementUserCopy() {
        document.querySelectorAll('.user-copy-button').forEach(button => {
            const buttonParent = button.parentElement;
            const textBlock = buttonParent.querySelector('p');

            if (textBlock && textBlock.innerHTML.length < 50) {
                button.style.display = 'none';
            }

            button.addEventListener('click', async function() {
                const textToCopy = textBlock.innerText;

                if (textToCopy.length >= 50) {
                    try {
                        await navigator.clipboard.writeText(textToCopy);
                        this.textContent = 'Copied!';
                        setTimeout(() => {
                            this.textContent = 'Copy';
                        }, 3000);
                    } catch (err) {
                        console.error('Failed to copy: ', err);
                    }
                }
            });
        });
    }

    // Copy function for the whole text block/aiMessage
    function CopyAll(UId, bt = null) {
        //console.log(UId)
        const textBlock = document.querySelector(UId);
        //console.log(textBlock)
        if (!textBlock) {
            console.error('Element not found: ', UId);
            return;
        }

        const textToCopy = textBlock.innerText;
        //console.log(textToCopy)

        if (textToCopy.length >= 50) {
            try {
                 navigator.clipboard.writeText(textToCopy);
                 if (bt){
                   bt.textContent = 'Copied!';
                setTimeout(() => {
                    bt.textContent = 'Copy';
                }, 3000)
                 }
            } catch (err) {
                console.error('Failed to copy: ', err);
            }
        } else {
            console.log('Text is too short to copy: ', textToCopy);
        }
    }

    // Function to remove the first conversation pairs to maintain conversation size limit
    function removeFirstConversationPairs(count = 2) {
        let removed = 0;
        while (removed < count && conversationHistory.length > 0) {
            const firstPair = conversationHistory[0];
            if (firstPair.role !== "system") {
                conversationHistory.shift();
                removed++;
            } else {
                // Skip system instructions
                break;
            }
        }
    }

    sendBtn.addEventListener("click", () => {
        const inputText = userInput.value.trim();
        if (inputText) {
            userInput.value = "";
            classifyText(inputText);
            document.getElementById('suggestions').classList.add('hidden')
        }
    });


    userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
            const inputText = userInput.value.trim();
            if (inputText) {
                userInput.value = "";
                classifyText(inputText);
                document.getElementById('suggestions').classList.add('hidden')
            }
        }
        });
    function copyBMan(){
        document.querySelectorAll(".Vision-user-copy-button").forEach(button => {
            console.log("Adding copy control")
            // Get the next sibling of the current element
            const nextSibling = button.nextElementSibling;

            // Check if the next sibling exists
            if (nextSibling) {
                // Get the first child of the next sibling
                const userTextChild = nextSibling.firstElementChild;

            if (userTextChild.innerHTML.length < 50) {
                button.classList.toggle('hidden');
            } else {
                console.log("userTextChild not found")
            }
            }
        });
    }

    window.CopyAll = CopyAll;

}

